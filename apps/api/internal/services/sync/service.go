// Copyright (c) 2026 dilocash
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file.

package sync

import (
	"context"
	"errors"
	"fmt"

	"connectrpc.com/connect"
	db "github.com/dilocash/dilocash-oss/apps/api/internal/generated/db/postgres"
	mappers "github.com/dilocash/dilocash-oss/apps/api/internal/generated/mappers"
	v1 "github.com/dilocash/dilocash-oss/apps/api/internal/generated/transport/dilocash/v1"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/shopspring/decimal"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// SyncServer implements the interface generated by gRPC/Connect
type SyncServer struct {
	store *db.Queries
	pool  *pgxpool.Pool
}

func NewSyncServer(pool *pgxpool.Pool) *SyncServer {
	return &SyncServer{
		store: db.New(pool), // sqlc.New accepts a DB TX or a Pool
		pool:  pool,
	}
}

func (s *SyncServer) PullChanges(
	ctx context.Context,
	req *v1.PullChangesRequest,
) (*v1.PullChangesResponse, error) {
	converter := &mappers.ConverterImpl{}
	profileId := ctx.Value("user_id").(string)
	lastPulledAt := req.GetLastPulledAt()

	fmt.Println("profileId", profileId)
	fmt.Println("lastPulledAt", lastPulledAt)
	// execute query to get transactions since lastPulledAt
	createdCommandsResult, err := s.store.ListCommandsByProfileIdAndCreatedAfter(ctx, db.ListCommandsByProfileIdAndCreatedAfterParams{
		ProfileID: uuid.MustParse(profileId),
		CreatedAt: lastPulledAt.AsTime(),
		Limit:     100,
		Offset:    0,
	})
	createdIntentsResult, err := s.store.ListIntentsByProfileIdAndCreatedAfter(ctx, db.ListIntentsByProfileIdAndCreatedAfterParams{
		ProfileID: uuid.MustParse(profileId),
		CreatedAt: lastPulledAt.AsTime(),
		Limit:     100,
		Offset:    0,
	})
	createdTransactionsResult, err := s.store.ListTransactionsByProfileIdAndCreatedAfter(ctx, db.ListTransactionsByProfileIdAndCreatedAfterParams{
		ProfileID: uuid.MustParse(profileId),
		CreatedAt: lastPulledAt.AsTime(),
		Limit:     100,
		Offset:    0,
	})
	fmt.Println("createdCommandsResult", createdCommandsResult)
	fmt.Println("createdIntentsResult", createdIntentsResult)
	fmt.Println("createdTransactionsResult", createdTransactionsResult)
	// Fetch changes created after lastPulledAt
	var createdCommands []*v1.Command
	var createdIntents []*v1.Intent
	var createdTransactions []*v1.Transaction
	for _, dbCommandResult := range createdCommandsResult {
		dbCommand := dbCommandResult
		domainCommand := converter.CommandFromDBToDomain(dbCommand)
		createdCommands = append(createdCommands, converter.ToTransportCommand(domainCommand))
	}
	for _, dbIntentResult := range createdIntentsResult {
		dbIntent := dbIntentResult
		domainIntent := converter.IntentFromDBToDomain(dbIntent)
		createdIntents = append(createdIntents, converter.ToTransportIntent(domainIntent))
	}
	for _, dbTransactionResult := range createdTransactionsResult {
		dbTransaction := dbTransactionResult
		domainTransaction := converter.TransactionFromDBToDomain(dbTransaction)
		createdTransactions = append(createdTransactions, converter.ToTransportTransaction(domainTransaction))
	}
	updatedChanges, err := s.store.ListCommandsByProfileIdAndUpdatedAfter(ctx, db.ListCommandsByProfileIdAndUpdatedAfterParams{
		ProfileID: uuid.MustParse(profileId),
		UpdatedAt: lastPulledAt.AsTime(),
		Limit:     100,
		Offset:    0,
	})
	if err != nil {
		return nil, connect.NewError(connect.CodeInternal, errors.New("failed to pull changes"))
	}

	fmt.Println("updatedChanges", updatedChanges)
	// Fetch changes created after lastPulledAt
	var updatedCommands []*v1.Command
	var updatedIntents []*v1.Intent
	var updatedTransactions []*v1.Transaction
	for _, dbCommandResult := range updatedChanges {
		dbCommand := dbCommandResult
		domainCommand := converter.CommandFromDBToDomain(dbCommand)
		updatedCommands = append(updatedCommands, converter.ToTransportCommand(domainCommand))
	}
	dbIntentResult, err := s.store.ListIntentsByProfileIdAndUpdatedAfter(ctx, db.ListIntentsByProfileIdAndUpdatedAfterParams{
		ProfileID: uuid.MustParse(profileId),
		UpdatedAt: lastPulledAt.AsTime(),
		Limit:     100,
		Offset:    0,
	})
	if err != nil {
		return nil, connect.NewError(connect.CodeInternal, errors.New("failed to pull changes"))
	}
	for _, dbIntent := range dbIntentResult {
		domainIntent := converter.IntentFromDBToDomain(dbIntent)
		updatedIntents = append(updatedIntents, converter.ToTransportIntent(domainIntent))
	}
	dbTransactionResult, err := s.store.ListTransactionsByProfileIdAndUpdatedAfter(ctx, db.ListTransactionsByProfileIdAndUpdatedAfterParams{
		ProfileID: uuid.MustParse(profileId),
		UpdatedAt: lastPulledAt.AsTime(),
		Limit:     100,
		Offset:    0,
	})
	if err != nil {
		return nil, connect.NewError(connect.CodeInternal, errors.New("failed to pull changes"))
	}
	for _, dbTransaction := range dbTransactionResult {
		domainTransaction := converter.TransactionFromDBToDomain(dbTransaction)
		updatedTransactions = append(updatedTransactions, converter.ToTransportTransaction(domainTransaction))
	}

	deletedCommandsParams := db.ListDeletedCommandsByProfileIdAndUpdatedAfterParams{
		ProfileID: uuid.MustParse(profileId),
		UpdatedAt: lastPulledAt.AsTime(),
		Limit:     100,
		Offset:    0,
	}
	fmt.Println("deletedCommandsParams", deletedCommandsParams)
	deletedCommandsResult, err := s.store.ListDeletedCommandsByProfileIdAndUpdatedAfter(ctx, deletedCommandsParams)
	if err != nil {
		return nil, connect.NewError(connect.CodeInternal, errors.New("failed to pull changes"))
	}
	fmt.Println("deletedCommandsResult", deletedCommandsResult)
	// Fetch changes created after lastPulledAt
	var deletedCommands []string
	for _, deletedCommand := range deletedCommandsResult {
		deletedCommands = append(deletedCommands, deletedCommand.String())
	}

	deletedIntentsParams := db.ListDeletedIntentsByProfileIdAndUpdatedAfterParams{
		ProfileID: uuid.MustParse(profileId),
		UpdatedAt: lastPulledAt.AsTime(),
		Limit:     100,
		Offset:    0,
	}
	fmt.Println("deletedIntentsParams", deletedIntentsParams)
	deletedIntentsResult, err := s.store.ListDeletedIntentsByProfileIdAndUpdatedAfter(ctx, deletedIntentsParams)
	if err != nil {
		return nil, connect.NewError(connect.CodeInternal, errors.New("failed to pull changes"))
	}
	fmt.Println("deletedIntentsResult", deletedIntentsResult)
	// Fetch changes created after lastPulledAt
	var deletedIntents []string
	for _, deletedIntent := range deletedIntentsResult {
		deletedIntents = append(deletedIntents, deletedIntent.String())
	}

	deletedTransactionsParams := db.ListDeletedTransactionsByProfileIdAndUpdatedAfterParams{
		ProfileID: uuid.MustParse(profileId),
		UpdatedAt: lastPulledAt.AsTime(),
		Limit:     100,
		Offset:    0,
	}
	fmt.Println("deletedTransactionsParams", deletedTransactionsParams)
	deletedTransactionsResult, err := s.store.ListDeletedTransactionsByProfileIdAndUpdatedAfter(ctx, deletedTransactionsParams)
	if err != nil {
		return nil, connect.NewError(connect.CodeInternal, errors.New("failed to pull changes"))
	}
	fmt.Println("deletedTransactionsResult", deletedTransactionsResult)
	// Fetch changes created after lastPulledAt
	var deletedTransactions []string
	for _, deletedTransaction := range deletedTransactionsResult {
		deletedTransactions = append(deletedTransactions, deletedTransaction.String())
	}

	return &v1.PullChangesResponse{
		Timestamp: timestamppb.Now(),
		Changes: &v1.Changes{
			Commands: &v1.CommandsList{
				Created: createdCommands,
				Updated: updatedCommands,
				Deleted: deletedCommands,
			},
			Intents: &v1.IntentsList{
				Created: createdIntents,
				Updated: updatedIntents,
				Deleted: deletedIntents,
			},
			Transactions: &v1.TransactionsList{
				Created: createdTransactions,
				Updated: updatedTransactions,
				Deleted: deletedTransactions,
			},
		},
	}, nil
}

func (s *SyncServer) PushChanges(
	ctx context.Context,
	req *v1.PushChangesRequest,
) (*v1.PushChangesResponse, error) {
	profileId := ctx.Value("user_id").(string)

	tx, err := s.pool.Begin(ctx)
	if err != nil {
		return nil, connect.NewError(connect.CodeInternal, errors.New("failed to begin transaction"))
	}
	defer tx.Rollback(ctx)

	qtx := s.store.WithTx(tx)

	for _, command := range req.GetChanges().GetCommands().GetCreated() {
		params := db.CreateCommandParams{
			ID:            uuid.MustParse(command.GetId()),
			ProfileID:     uuid.MustParse(profileId),
			CommandStatus: int32(command.GetCommandStatus().Number()),
			CreatedAt:     command.GetCreatedAt().AsTime(),
		}

		_, err := qtx.CreateCommand(ctx, params)
		if err != nil {
			fmt.Println("error", err)
			return nil, connect.NewError(connect.CodeInternal, errors.New("failed to store command"))
		}
	}

	for _, transaction := range req.GetChanges().GetTransactions().GetCreated() {
		category := transaction.GetCategory()
		description := transaction.GetDescription()
		params := db.CreateTransactionParams{
			ID:          uuid.MustParse(transaction.GetId()),
			CommandID:   uuid.MustParse(transaction.GetCommandId()),
			Amount:      decimal.RequireFromString(transaction.GetAmount()),
			Currency:    transaction.GetCurrency(),
			Category:    &category,
			Description: &description,
			CreatedAt:   transaction.GetCreatedAt().AsTime(),
		}
		_, err := qtx.CreateTransaction(ctx, params)
		if err != nil {
			fmt.Println("error", err)
			return nil, connect.NewError(connect.CodeInternal, errors.New("failed to store transaction"))
		}
	}

	for _, intent := range req.GetChanges().GetIntents().GetCreated() {
		textMessage := intent.GetTextMessage()
		audioMessage := intent.GetAudioMessage()
		imageMessage := intent.GetImageMessage()
		requiresReview := intent.GetRequiresReview()

		params := db.CreateIntentParams{
			ID:             uuid.MustParse(intent.GetId()),
			CommandID:      uuid.MustParse(intent.GetCommandId()),
			TextMessage:    &textMessage,
			AudioMessage:   &audioMessage,
			ImageMessage:   &imageMessage,
			IntentStatus:   int32(intent.GetIntentStatus().Number()),
			RequiresReview: &requiresReview,
			CreatedAt:      intent.GetCreatedAt().AsTime(),
		}
		_, err := qtx.CreateIntent(ctx, params)
		if err != nil {
			fmt.Println("error", err)
			return nil, connect.NewError(connect.CodeInternal, errors.New("failed to store intent"))
		}
	}

	for _, command := range req.GetChanges().GetCommands().GetUpdated() {
		params := db.UpdateCommandParams{
			ID:            uuid.MustParse(command.GetId()),
			CommandStatus: int32(command.GetCommandStatus().Number()),
		}

		_, err := qtx.UpdateCommand(ctx, params)
		if err != nil {
			fmt.Println("error", err)
			return nil, connect.NewError(connect.CodeInternal, errors.New("failed to store command"))
		}
	}

	for _, transaction := range req.GetChanges().GetTransactions().GetUpdated() {
		category := transaction.GetCategory()
		description := transaction.GetDescription()
		params := db.UpdateTransactionParams{
			ID:          uuid.MustParse(transaction.GetId()),
			Amount:      decimal.RequireFromString(transaction.GetAmount()),
			Currency:    transaction.GetCurrency(),
			Category:    &category,
			Description: &description,
		}
		_, err := qtx.UpdateTransaction(ctx, params)
		if err != nil {
			fmt.Println("error", err)
			return nil, connect.NewError(connect.CodeInternal, errors.New("failed to store transaction"))
		}
	}

	for _, intent := range req.GetChanges().GetIntents().GetUpdated() {
		textMessage := intent.GetTextMessage()
		audioMessage := intent.GetAudioMessage()
		imageMessage := intent.GetImageMessage()
		requiresReview := intent.GetRequiresReview()

		params := db.UpdateIntentParams{
			ID:             uuid.MustParse(intent.GetId()),
			TextMessage:    &textMessage,
			AudioMessage:   &audioMessage,
			ImageMessage:   &imageMessage,
			IntentStatus:   int32(intent.GetIntentStatus().Number()),
			RequiresReview: &requiresReview,
		}
		_, err := qtx.UpdateIntent(ctx, params)
		if err != nil {
			fmt.Println("error", err)
			return nil, connect.NewError(connect.CodeInternal, errors.New("failed to store intent"))
		}
	}

	for _, command := range req.GetChanges().GetCommands().GetDeleted() {
		err := qtx.DeleteCommand(ctx, uuid.MustParse(command))
		if err != nil {
			fmt.Println("error", err)
			return nil, connect.NewError(connect.CodeInternal, errors.New("failed to delete command"))
		}
	}

	for _, transaction := range req.GetChanges().GetTransactions().GetDeleted() {
		err := qtx.DeleteTransaction(ctx, uuid.MustParse(transaction))
		if err != nil {
			fmt.Println("error", err)
			return nil, connect.NewError(connect.CodeInternal, errors.New("failed to delete transaction"))
		}
	}

	for _, intent := range req.GetChanges().GetIntents().GetDeleted() {
		err := qtx.DeleteIntent(ctx, uuid.MustParse(intent))
		if err != nil {
			fmt.Println("error", err)
			return nil, connect.NewError(connect.CodeInternal, errors.New("failed to delete intent"))
		}
	}

	res := tx.Commit(ctx)
	if res != nil {
		fmt.Println("error", res)
		return nil, connect.NewError(connect.CodeInternal, errors.New("failed to commit transaction"))
	}

	return &v1.PushChangesResponse{
		Ok:          true,
		ConflictIds: []string{},
	}, nil
}
