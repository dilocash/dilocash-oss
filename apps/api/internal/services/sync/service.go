// Copyright (c) 2026 dilocash
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file.

package transaction

import (
	"context"
	"errors"

	"connectrpc.com/connect"
	db "github.com/dilocash/dilocash-oss/apps/api/internal/generated/db/postgres"
	mappers "github.com/dilocash/dilocash-oss/apps/api/internal/generated/mappers"
	v1 "github.com/dilocash/dilocash-oss/apps/api/internal/generated/transport/dilocash/v1"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
)

// SyncServer implements the interface generated by gRPC/Connect
type SyncServer struct {
	store *db.Queries
	pool  *pgxpool.Pool
}

func NewSyncServer(pool *pgxpool.Pool) *SyncServer {
	return &SyncServer{
		store: db.New(pool), // sqlc.New accepts a DB TX or a Pool
		pool:  pool,
	}
}

func (s *SyncServer) PullChanges(
	ctx context.Context,
	req *v1.PullChangesRequest,
) (*v1.PullChangesResponse, error) {

	lastPulledAt := req.GetLastPulledAt()

	// execute query to get transactions since lastPulledAt
	params := db.ListCommandsByUserIdParams{
		UserID:    uuid.MustParse("019c4d6b-268d-791a-9000-000000000001"),
		UpdatedAt: lastPulledAt.AsTime(),
		Limit:     100,
		Offset:    0,
	}

	changes, err := s.store.ListCommandsByUserId(ctx, params)

	// Fetch changes updated after lastPulledAt
	// Note: Always store and compare timestamps in UTC
	var created []*v1.Command
	var updated []*v1.Command
	var deleted []string
	converter := &mappers.ConverterImpl{}
	for _, dbCommand := range changes {
		domainCommand := converter.CommandFromDBToDomain(dbCommand)
		transportCommand := converter.ToTransportCommand(domainCommand)
		created = append(created, transportCommand)
	}

	if err != nil {
		return nil, connect.NewError(connect.CodeInternal, errors.New("failed to pull changes"))
	}

	return &v1.PullChangesResponse{
		Changes: &v1.Changes{
			Commands: &v1.CommandsList{
				Created: created,
				Updated: updated,
				Deleted: deleted,
			},
			Intents: &v1.IntentsList{
				Created: []*v1.Intent{},
				Updated: []*v1.Intent{},
				Deleted: []string{},
			},
			Transactions: &v1.TransactionsList{
				Created: []*v1.Transaction{},
				Updated: []*v1.Transaction{},
				Deleted: []string{},
			},
		},
	}, nil
}

func (s *SyncServer) PushChanges(
	ctx context.Context,
	req *v1.PushChangesRequest,
) (*v1.PushChangesResponse, error) {

	// // 1. Mapeo de gRPC Request a sqlc Params
	// converter := &mappers.ConverterImpl{}
	// domainCommand := converter.TransactionFromTransportToDomain(req.GetLastPulledAt())
	// dbTransactionParams := converter.ToDBCreateTransactionParams(domainTransaction)

	// // 2. Ejecuci√≥n de la consulta usando sqlc
	// transaction, err := s.store.CreateTransaction(ctx, dbTransactionParams)
	// if err != nil {
	// 	// Manejo de errores profesional (Logging + gRPC Codes)
	// 	// log.Fatal("failed to store transaction", err)
	// 	return nil, connect.NewError(connect.CodeInternal, errors.New("failed to store transaction"))
	// }

	// domainTransactionResult := converter.TransactionFromDBToDomain(transaction)
	// // 4. Mapeo de gRPC Response a Transport Response

	// transportTransactionResult := converter.ToTransportTransaction(domainTransactionResult)
	// // 3. Respuesta exitosa
	// return &v1.CreateTransactionResponse{
	// 	Transaction: transportTransactionResult,
	// }, nil

	return &v1.PushChangesResponse{}, errors.New("PushChanges called. not implemented yet")
}
