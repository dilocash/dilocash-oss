// Copyright (c) 2026 dilocash
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file.

package sync

import (
	"context"
	"errors"
	"log/slog"

	"connectrpc.com/connect"
	db "github.com/dilocash/dilocash-oss/apps/api/internal/generated/db/postgres"
	mappers "github.com/dilocash/dilocash-oss/apps/api/internal/generated/mappers"
	v1 "github.com/dilocash/dilocash-oss/apps/api/internal/generated/transport/dilocash/v1"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/shopspring/decimal"
	"google.golang.org/protobuf/types/known/timestamppb"
)

// SyncServer implements the interface generated by gRPC/Connect
type SyncServer struct {
	store *db.Queries
	pool  *pgxpool.Pool
}

func NewSyncServer(pool *pgxpool.Pool) *SyncServer {
	return &SyncServer{
		store: db.New(pool), // sqlc.New accepts a DB TX or a Pool
		pool:  pool,
	}
}

func (s *SyncServer) PullChanges(
	ctx context.Context,
	req *v1.PullChangesRequest,
) (*v1.PullChangesResponse, error) {
	converter := &mappers.ConverterImpl{}
	profileId := ctx.Value("user_id").(string)
	lastPulledAt := req.GetLastPulledAt()

	commandsList := &v1.CommandsList{
		Created: []*v1.Command{},
		Updated: []*v1.Command{},
		Deleted: []string{},
	}
	intentsList := &v1.IntentsList{
		Created: []*v1.Intent{},
		Updated: []*v1.Intent{},
		Deleted: []string{},
	}
	transactionsList := &v1.TransactionsList{
		Created: []*v1.Transaction{},
		Updated: []*v1.Transaction{},
		Deleted: []string{},
	}

	slog.Info("pulling changes", "profileId", profileId, "lastPulledAt", lastPulledAt)
	// execute query to get transactions since lastPulledAt
	createdCommandsResult, err := s.store.ListCommandsByProfileIdAndCreatedAfter(ctx, db.ListCommandsByProfileIdAndCreatedAfterParams{
		ProfileID: uuid.MustParse(profileId),
		CreatedAt: lastPulledAt.AsTime(),
		Limit:     100,
		Offset:    0,
	})
	if err != nil {
		slog.Error("failed to pull created commands", "error", err)
		return nil, connect.NewError(connect.CodeInternal, errors.New("failed to pull created commands"))
	}
	createdIntentsResult, err := s.store.ListIntentsByProfileIdAndCreatedAfter(ctx, db.ListIntentsByProfileIdAndCreatedAfterParams{
		ProfileID: uuid.MustParse(profileId),
		CreatedAt: lastPulledAt.AsTime(),
		Limit:     100,
		Offset:    0,
	})
	if err != nil {
		slog.Error("failed to pull created intents", "error", err)
		return nil, connect.NewError(connect.CodeInternal, errors.New("failed to pull created intents"))
	}
	createdTransactionsResult, err := s.store.ListTransactionsByProfileIdAndCreatedAfter(ctx, db.ListTransactionsByProfileIdAndCreatedAfterParams{
		ProfileID: uuid.MustParse(profileId),
		CreatedAt: lastPulledAt.AsTime(),
		Limit:     100,
		Offset:    0,
	})
	if err != nil {
		slog.Error("failed to pull created transactions", "error", err)
		return nil, connect.NewError(connect.CodeInternal, errors.New("failed to pull created transactions"))
	}
	// Fetch changes created after lastPulledAt
	var createdCommands []*v1.Command
	var createdIntents []*v1.Intent
	var createdTransactions []*v1.Transaction
	for _, dbCommandResult := range createdCommandsResult {
		dbCommand := dbCommandResult
		domainCommand := converter.CommandFromDBToDomain(dbCommand)
		createdCommands = append(createdCommands, converter.ToTransportCommand(domainCommand))
	}
	for _, dbIntentResult := range createdIntentsResult {
		dbIntent := dbIntentResult
		domainIntent := converter.IntentFromDBToDomain(dbIntent)
		createdIntents = append(createdIntents, converter.ToTransportIntent(domainIntent))
	}
	for _, dbTransactionResult := range createdTransactionsResult {
		dbTransaction := dbTransactionResult
		domainTransaction := converter.TransactionFromDBToDomain(dbTransaction)
		createdTransactions = append(createdTransactions, converter.ToTransportTransaction(domainTransaction))
	}

	commandsList.Created = createdCommands
	intentsList.Created = createdIntents
	transactionsList.Created = createdTransactions

	if lastPulledAt == nil {
		slog.Info("lastPulledAt is nil (initial sync), only created items will be fetched")
		return pullInitialSync(ctx, s)
	}

	updatedChangesCommandsResult, err := s.store.ListCommandsByProfileIdAndUpdatedAfter(ctx, db.ListCommandsByProfileIdAndUpdatedAfterParams{
		ProfileID: uuid.MustParse(profileId),
		UpdatedAt: lastPulledAt.AsTime(),
		Limit:     100,
		Offset:    0,
	})
	if err != nil {
		slog.Error("failed to pull updated commands", "error", err)
		return nil, connect.NewError(connect.CodeInternal, errors.New("failed to pull updated commands"))
	}
	// Fetch changes created after lastPulledAt
	var updatedCommands []*v1.Command
	var updatedIntents []*v1.Intent
	var updatedTransactions []*v1.Transaction
	for _, dbCommandResult := range updatedChangesCommandsResult {
		dbCommand := dbCommandResult
		domainCommand := converter.CommandFromDBToDomain(dbCommand)
		updatedCommands = append(updatedCommands, converter.ToTransportCommand(domainCommand))
	}
	dbIntentResult, err := s.store.ListIntentsByProfileIdAndUpdatedAfter(ctx, db.ListIntentsByProfileIdAndUpdatedAfterParams{
		ProfileID: uuid.MustParse(profileId),
		UpdatedAt: lastPulledAt.AsTime(),
		Limit:     100,
		Offset:    0,
	})
	if err != nil {
		slog.Error("failed to pull updated intents", "error", err)
		return nil, connect.NewError(connect.CodeInternal, errors.New("failed to pull updated intents"))
	}
	for _, dbIntent := range dbIntentResult {
		domainIntent := converter.IntentFromDBToDomain(dbIntent)
		updatedIntents = append(updatedIntents, converter.ToTransportIntent(domainIntent))
	}
	dbTransactionResult, err := s.store.ListTransactionsByProfileIdAndUpdatedAfter(ctx, db.ListTransactionsByProfileIdAndUpdatedAfterParams{
		ProfileID: uuid.MustParse(profileId),
		UpdatedAt: lastPulledAt.AsTime(),
		Limit:     100,
		Offset:    0,
	})
	if err != nil {
		slog.Error("failed to pull updated transactions", "error", err)
		return nil, connect.NewError(connect.CodeInternal, errors.New("failed to pull updated transactions"))
	}
	for _, dbTransaction := range dbTransactionResult {
		domainTransaction := converter.TransactionFromDBToDomain(dbTransaction)
		updatedTransactions = append(updatedTransactions, converter.ToTransportTransaction(domainTransaction))
	}

	commandsList.Updated = updatedCommands
	intentsList.Updated = updatedIntents
	transactionsList.Updated = updatedTransactions

	deletedCommandsParams := db.ListDeletedCommandsByProfileIdAndUpdatedAfterParams{
		ProfileID: uuid.MustParse(profileId),
		UpdatedAt: lastPulledAt.AsTime(),
		Limit:     100,
		Offset:    0,
	}

	deletedCommandsResult, err := s.store.ListDeletedCommandsByProfileIdAndUpdatedAfter(ctx, deletedCommandsParams)
	if err != nil {
		slog.Error("failed to pull deleted commands", "error", err)
		return nil, connect.NewError(connect.CodeInternal, errors.New("failed to pull deleted commands"))
	}
	// Fetch changes created after lastPulledAt
	var deletedCommands []string
	for _, deletedCommand := range deletedCommandsResult {
		deletedCommands = append(deletedCommands, deletedCommand.String())
	}

	deletedIntentsParams := db.ListDeletedIntentsByProfileIdAndUpdatedAfterParams{
		ProfileID: uuid.MustParse(profileId),
		UpdatedAt: lastPulledAt.AsTime(),
		Limit:     100,
		Offset:    0,
	}
	deletedIntentsResult, err := s.store.ListDeletedIntentsByProfileIdAndUpdatedAfter(ctx, deletedIntentsParams)
	if err != nil {
		slog.Error("failed to pull deleted intents", "error", err)
		return nil, connect.NewError(connect.CodeInternal, errors.New("failed to pull deleted intents"))
	}
	// Fetch changes created after lastPulledAt
	var deletedIntents []string
	for _, deletedIntent := range deletedIntentsResult {
		deletedIntents = append(deletedIntents, deletedIntent.String())
	}

	deletedTransactionsParams := db.ListDeletedTransactionsByProfileIdAndUpdatedAfterParams{
		ProfileID: uuid.MustParse(profileId),
		UpdatedAt: lastPulledAt.AsTime(),
		Limit:     100,
		Offset:    0,
	}
	deletedTransactionsResult, err := s.store.ListDeletedTransactionsByProfileIdAndUpdatedAfter(ctx, deletedTransactionsParams)
	if err != nil {
		slog.Error("failed to pull deleted transactions", "error", err)
		return nil, connect.NewError(connect.CodeInternal, errors.New("failed to pull deleted transactions"))
	}
	// Fetch changes created after lastPulledAt
	var deletedTransactions []string
	for _, deletedTransaction := range deletedTransactionsResult {
		deletedTransactions = append(deletedTransactions, deletedTransaction.String())
	}

	commandsList.Deleted = deletedCommands
	intentsList.Deleted = deletedIntents
	transactionsList.Deleted = deletedTransactions

	slog.Info("changes pulled successfully", "createdCommands", len(createdCommands), "updatedCommands", len(updatedCommands), "deletedCommands", len(deletedCommands), "createdIntents", len(createdIntents), "updatedIntents", len(updatedIntents), "deletedIntents", len(deletedIntents), "createdTransactions", len(createdTransactions), "updatedTransactions", len(updatedTransactions), "deletedTransactions", len(deletedTransactions))

	return buildPullChangesResponse(commandsList, intentsList, transactionsList)
}

func pullInitialSync(ctx context.Context, s *SyncServer) (*v1.PullChangesResponse, error) {
	converter := &mappers.ConverterImpl{}
	profileId := ctx.Value("user_id").(string)
	slog.Info("initial sync", "profileId", profileId)

	commandsList := &v1.CommandsList{
		Created: []*v1.Command{},
		Updated: []*v1.Command{},
		Deleted: []string{},
	}
	intentsList := &v1.IntentsList{
		Created: []*v1.Intent{},
		Updated: []*v1.Intent{},
		Deleted: []string{},
	}
	transactionsList := &v1.TransactionsList{
		Created: []*v1.Transaction{},
		Updated: []*v1.Transaction{},
		Deleted: []string{},
	}

	slog.Info("pulling changes", "profileId", profileId)
	// execute query to get transactions since lastPulledAt
	createdCommandsResult, err := s.store.ListCommandsByProfileId(ctx, db.ListCommandsByProfileIdParams{
		ProfileID: uuid.MustParse(profileId),
		Limit:     100,
		Offset:    0,
	})
	if err != nil {
		slog.Error("failed to pull created commands", "error", err)
		return nil, connect.NewError(connect.CodeInternal, errors.New("failed to pull created commands"))
	}
	createdIntentsResult, err := s.store.ListIntentsByProfileId(ctx, db.ListIntentsByProfileIdParams{
		ProfileID: uuid.MustParse(profileId),
		Limit:     100,
		Offset:    0,
	})
	if err != nil {
		slog.Error("failed to pull created intents", "error", err)
		return nil, connect.NewError(connect.CodeInternal, errors.New("failed to pull created intents"))
	}
	createdTransactionsResult, err := s.store.ListTransactionsByProfileId(ctx, db.ListTransactionsByProfileIdParams{
		ProfileID: uuid.MustParse(profileId),
		Limit:     100,
		Offset:    0,
	})
	if err != nil {
		slog.Error("failed to pull created transactions", "error", err)
		return nil, connect.NewError(connect.CodeInternal, errors.New("failed to pull created transactions"))
	}

	var createdCommands []*v1.Command
	var createdIntents []*v1.Intent
	var createdTransactions []*v1.Transaction
	for _, dbCommandResult := range createdCommandsResult {
		dbCommand := dbCommandResult
		domainCommand := converter.CommandFromDBToDomain(dbCommand)
		createdCommands = append(createdCommands, converter.ToTransportCommand(domainCommand))
	}
	for _, dbIntentResult := range createdIntentsResult {
		dbIntent := dbIntentResult
		domainIntent := converter.IntentFromDBToDomain(dbIntent)
		createdIntents = append(createdIntents, converter.ToTransportIntent(domainIntent))
	}
	for _, dbTransactionResult := range createdTransactionsResult {
		dbTransaction := dbTransactionResult
		domainTransaction := converter.TransactionFromDBToDomain(dbTransaction)
		createdTransactions = append(createdTransactions, converter.ToTransportTransaction(domainTransaction))
	}

	commandsList.Created = createdCommands
	intentsList.Created = createdIntents
	transactionsList.Created = createdTransactions

	return buildPullChangesResponse(commandsList, intentsList, transactionsList)
}

func buildPullChangesResponse(commandsList *v1.CommandsList, intentsList *v1.IntentsList, transactionsList *v1.TransactionsList) (*v1.PullChangesResponse, error) {
	return &v1.PullChangesResponse{
		Timestamp: timestamppb.Now(),
		Changes: &v1.Changes{
			Commands:     commandsList,
			Intents:      intentsList,
			Transactions: transactionsList,
		},
	}, nil
}

func (s *SyncServer) PushChanges(
	ctx context.Context,
	req *v1.PushChangesRequest,
) (*v1.PushChangesResponse, error) {
	profileId := ctx.Value("user_id").(string)

	slog.Info("pushing changes", "profileId", profileId, "changes", req.GetChanges(), "lastPulledAt", req.GetLastPulledAt())
	tx, err := s.pool.Begin(ctx)
	if err != nil {
		return nil, connect.NewError(connect.CodeInternal, errors.New("failed to begin transaction"))
	}
	defer tx.Rollback(ctx)

	qtx := s.store.WithTx(tx)

	for _, command := range req.GetChanges().GetCommands().GetCreated() {
		params := db.CreateCommandParams{
			ID:            uuid.MustParse(command.GetId()),
			ProfileID:     uuid.MustParse(profileId),
			CommandStatus: int32(command.GetCommandStatus().Number()),
			CreatedAt:     command.GetCreatedAt().AsTime(),
		}

		_, err := qtx.CreateCommand(ctx, params)
		if err != nil {
			slog.Error("failed to store command", "error", err)
			return nil, connect.NewError(connect.CodeInternal, errors.New("failed to store command"))
		}
	}

	for _, transaction := range req.GetChanges().GetTransactions().GetCreated() {
		category := transaction.GetCategory()
		description := transaction.GetDescription()
		params := db.CreateTransactionParams{
			ID:          uuid.MustParse(transaction.GetId()),
			CommandID:   uuid.MustParse(transaction.GetCommandId()),
			Amount:      decimal.RequireFromString(transaction.GetAmount()),
			Currency:    transaction.GetCurrency(),
			Category:    &category,
			Description: &description,
			CreatedAt:   transaction.GetCreatedAt().AsTime(),
		}
		_, err := qtx.CreateTransaction(ctx, params)
		if err != nil {
			slog.Error("failed to store transaction", "error", err)
			return nil, connect.NewError(connect.CodeInternal, errors.New("failed to store transaction"))
		}
	}

	for _, intent := range req.GetChanges().GetIntents().GetCreated() {
		textMessage := intent.GetTextMessage()
		audioMessage := intent.GetAudioMessage()
		imageMessage := intent.GetImageMessage()
		requiresReview := intent.GetRequiresReview()

		params := db.CreateIntentParams{
			ID:             uuid.MustParse(intent.GetId()),
			CommandID:      uuid.MustParse(intent.GetCommandId()),
			TextMessage:    &textMessage,
			AudioMessage:   &audioMessage,
			ImageMessage:   &imageMessage,
			IntentStatus:   int32(intent.GetIntentStatus().Number()),
			RequiresReview: &requiresReview,
			CreatedAt:      intent.GetCreatedAt().AsTime(),
		}
		_, err := qtx.CreateIntent(ctx, params)
		if err != nil {
			slog.Error("failed to store intent", "error", err)
			return nil, connect.NewError(connect.CodeInternal, errors.New("failed to store intent"))
		}
	}

	for _, command := range req.GetChanges().GetCommands().GetUpdated() {
		params := db.UpdateCommandParams{
			ID:            uuid.MustParse(command.GetId()),
			CommandStatus: int32(command.GetCommandStatus().Number()),
		}

		_, err := qtx.UpdateCommand(ctx, params)
		if err != nil {
			slog.Error("failed to update command", "error", err)
			return nil, connect.NewError(connect.CodeInternal, errors.New("failed to update command"))
		}
	}

	for _, transaction := range req.GetChanges().GetTransactions().GetUpdated() {
		category := transaction.GetCategory()
		description := transaction.GetDescription()
		params := db.UpdateTransactionParams{
			ID:          uuid.MustParse(transaction.GetId()),
			Amount:      decimal.RequireFromString(transaction.GetAmount()),
			Currency:    transaction.GetCurrency(),
			Category:    &category,
			Description: &description,
		}
		_, err := qtx.UpdateTransaction(ctx, params)
		if err != nil {
			slog.Error("failed to update transaction", "error", err)
			return nil, connect.NewError(connect.CodeInternal, errors.New("failed to update transaction"))
		}
	}

	for _, intent := range req.GetChanges().GetIntents().GetUpdated() {
		textMessage := intent.GetTextMessage()
		audioMessage := intent.GetAudioMessage()
		imageMessage := intent.GetImageMessage()
		requiresReview := intent.GetRequiresReview()

		params := db.UpdateIntentParams{
			ID:             uuid.MustParse(intent.GetId()),
			TextMessage:    &textMessage,
			AudioMessage:   &audioMessage,
			ImageMessage:   &imageMessage,
			IntentStatus:   int32(intent.GetIntentStatus().Number()),
			RequiresReview: &requiresReview,
		}
		_, err := qtx.UpdateIntent(ctx, params)
		if err != nil {
			slog.Error("failed to update intent", "error", err)
			return nil, connect.NewError(connect.CodeInternal, errors.New("failed to update intent"))
		}
	}

	for _, command := range req.GetChanges().GetCommands().GetDeleted() {
		err := qtx.DeleteCommand(ctx, uuid.MustParse(command))
		if err != nil {
			slog.Error("failed to delete command", "error", err)
			return nil, connect.NewError(connect.CodeInternal, errors.New("failed to delete command"))
		}
	}

	for _, transaction := range req.GetChanges().GetTransactions().GetDeleted() {
		err := qtx.DeleteTransaction(ctx, uuid.MustParse(transaction))
		if err != nil {
			slog.Error("failed to delete transaction", "error", err)
			return nil, connect.NewError(connect.CodeInternal, errors.New("failed to delete transaction"))
		}
	}

	for _, intent := range req.GetChanges().GetIntents().GetDeleted() {
		err := qtx.DeleteIntent(ctx, uuid.MustParse(intent))
		if err != nil {
			slog.Error("failed to delete intent", "error", err)
			return nil, connect.NewError(connect.CodeInternal, errors.New("failed to delete intent"))
		}
	}

	res := tx.Commit(ctx)
	if res != nil {
		slog.Error("failed to commit transaction", "error", res)
		return nil, connect.NewError(connect.CodeInternal, errors.New("failed to commit transaction"))
	}

	slog.Info("changes pushed successfully", "profileId", profileId)

	return &v1.PushChangesResponse{
		Ok:          true,
		ConflictIds: []string{},
	}, nil
}
